/********************************************************************************
*
* File: pcat.cup
* The PCAT parser
*
********************************************************************************/

package edu.uta.pcat;

import scala.collection.immutable.*;
import scala.Tuple2;
import java_cup.runtime.*;


parser code {:

    static int[] tokens = {
      sym.error, sym.ID, sym.STRING_LITERAL, sym.INTEGER_LITERAL, sym.REAL_LITERAL,
      sym.AND, sym.ARRAY, sym.BEGIN, sym.BY, sym.DIV, sym.DO, sym.ELSE, sym.ELSIF, sym.END,
      sym.EXIT, sym.FOR, sym.IF, sym.IS, sym.LOOP, sym.MOD, sym.NOT, sym.OF, sym.OR,
      sym.PROCEDURE, sym.PROGRAM, sym.READ, sym.RECORD, sym.RETURN, sym.THEN, sym.TO,
      sym.TYPE, sym.VAR, sym.WHILE, sym.WRITE, sym.ASGN, sym.PLUS, sym.MINUS, sym.TIMES, sym.SLASH,
      sym.LT, sym.LEQ, sym.GT, sym.GEQ, sym.EQ, sym.NEQ, sym.COLON, sym.SEMI, sym.COMMA, sym.DOT,
      sym.LPAREN, sym.RPAREN, sym.LSQBRA, sym.RSQBRA, sym.LCUBRA, sym.RCUBRA
    };

    static String[] token_names = {
      "error", "ID", "STRING_LITERAL", "INTEGER_LITERAL", "REAL_LITERAL",
      "AND", "ARRAY", "BEGIN", "BY", "DIV", "DO", "ELSE", "ELSIF", "END",
      "EXIT", "FOR", "IF", "IS", "LOOP", "MOD", "NOT", "OF", "OR",
      "PROCEDURE", "PROGRAM", "READ", "RECORD", "RETURN", "THEN", "TO",
      "TYPE", "VAR", "WHILE", "WRITE", "ASGN :=", "PLUS +", "MINUS -", "TIMES *", "SLASH /",
      "LT <", "LEQ <=", "GT >", "GEQ >=", "EQ =", "NEQ <>", "COLON :", "SEMI ;", "COMMA ,", "DOT .",
      "LPAREN (", "RPAREN )", "LSQBRA [", "RSQBRA ]", "LCUBRA "+'{', "RCUBRA "+'}'
    };

    public static String print ( Symbol s ) {
        for ( int i = 0; i < tokens.length; i++ ) {
            if (tokens[i] == s.sym) {
                String res = token_names[i] + " ";
                if (s.value == null)
                    return res;
                else if (s.value instanceof Integer)
                    return res + ((Integer) s.value).intValue();
                else if (s.value instanceof Float)
                    return res + ((Float) s.value).floatValue();
                else if (s.value instanceof String)
                    return res + "\"" + (String) s.value + "\"";
            }
        };
        return "?";
    }

    public void syntax_error ( Symbol token ) {
        System.err.println("*** Syntax Error: " + print(token) + " (line: " + token.left
                           + ", column: " + token.right + ")");
        System.exit(1);
    }

    /** nil is the empty list */
    final static List nil = Nil$.MODULE$;

    /** Append list2 at the end of list1 (ie, return a new list containing
        the elements from list1 followed by the elements from list2) */
    static<T> List<T> append ( List<T> list1, List<T> list2 ) {
        return list1.$colon$colon$colon(list2);
    }

    /** append the element elem at the end of the list
       (ie, return a new list containing the list followed by the elem) */
    static<T> List<T> append ( List<T> list, T elem ) {
        return nil.$colon$colon(elem).$colon$colon$colon(list);
    }

    /** Insert the element elem at the beginning of the list
        (ie, return a new list containing the elem followed by the list) */
    static<T> List<T> add ( T elem, List<T> list ) {
        return list.$colon$colon(elem);
    }

:};

/* Terminals (tokens returned by the scanner). */
terminal String  ID, STRING_LITERAL;
terminal Integer INTEGER_LITERAL;
terminal Float   REAL_LITERAL;
terminal         AND, ARRAY, BEGIN, BY, DIV, DO, ELSE, ELSIF, END, EXIT, FOR, IF, IS, LOOP, MOD,
                 NOT, OF, OR, PROCEDURE, PROGRAM, READ, RECORD, RETURN, THEN, TO, TYPE, VAR, WHILE,
                 WRITE, ASGN, PLUS, MINUS, TIMES, SLASH, LT, LEQ, GT, GEQ, EQ, NEQ, COLON, SEMI,
                 COMMA, DOT, LPAREN, RPAREN, LSQBRA, RSQBRA, LCUBRA, RCUBRA, UMINUS;

non terminal             program;
non terminal Body        body;
non terminal Expr        expression;
non terminal Stmt        statement;
non terminal List<Stmt>  statement_lst;
non terminal             number;
non terminal             array_init;
non terminal             array_inits;
non terminal             array_inits1;
non terminal             record_inits;
non terminal             record_inits1;
non terminal             actual_params;
non terminal             actual_params1;
non terminal             lvalue;
non terminal             write_expr;
non terminal             write_params;
non terminal             write_params1;
non terminal             fp_section;
non terminal             fp_section1;
non terminal             formal_params;
non terminal             formal_params1;
non terminal             component;
non terminal             type;
non terminal             component_lst;
non terminal             procedure_decl;
non terminal             procedure_decls;
non terminal             procedure_decls1;
non terminal             type_decl;
non terminal             type_decls;
non terminal             type_decls1;
non terminal             var_decl;
non terminal             var_decl1;
non terminal             var_decls;
non terminal             var_decls_lst;
non terminal             declaration;
non terminal             typename;
non terminal             declaration_lst;

precedence nonassoc ELSE;
precedence nonassoc ELSIF;
precedence right  OR;
precedence right  AND;
precedence nonassoc NOT;
precedence left   EQ, LT, GT, LEQ, GEQ, NEQ, LPAREN;
precedence left   PLUS, MINUS;
precedence left   TIMES, SLASH, DIV, MOD;

start with program;

program         ::= PROGRAM IS body:b SEMI            {: PCAT.setAST(new ProcDecl("main","NoType",nil,b)); :}
                ;
body            ::= declaration_lst BEGIN statement_lst:sl END
                | BEGIN statement_lst:sl END        {: RESULT = new Body(nil,sl); :}
                ;
statement_lst   ::= statement:s                       {: RESULT = add(s,nil); :}    /* New Symbol*/
                |   statement_lst:sl statement:s      {: RESULT = append(sl,s); :}
                |   statement_lst COMMA lvalue
                |   COMMA lvalue
                ;
declaration_lst ::= declaration_lst declaration   /* New Symbol*/
                |   declaration
                ;
declaration     ::= VAR var_decls
                | TYPE type_decls
                | PROCEDURE procedure_decls
                ;
var_decls       ::= var_decl var_decls_lst  
                ;
var_decls_lst   ::= var_decls_lst var_decl   /* New Symbol*/
                ;
var_decl        ::= ID var_decl1 ASGN expression SEMI
                |   ID var_decl1 COLON typename ASGN expression SEMI
                ;
var_decl1       ::= var_decl1 COMMA ID /* New Symbol*/
                |   COMMA ID
                ;
type_decls      ::= type_decl type_decls1
                ;
type_decls1     ::= type_decls1 AND type_decl  /* New Symbol*/
                |   AND type_decl
                ;
type_decl       ::= typename IS type SEMI
                ;
procedure_decls ::= procedure_decl procedure_decls1
                ;
procedure_decls1::= procedure_decls1 AND procedure_decl  /* New Symbol*/
                |   AND procedure_decl
                ;
procedure_decl  ::= ID formal_params IS body SEMI
                |   ID formal_params COLON typename IS body SEMI
                ;
typename        ::= ID
                ;
type            ::= ARRAY OF ID
                |   RECORD component component_lst END
                ;
component_lst   ::= component_lst component   /* New Symbol*/
                |   component
                ;
component       ::= ID COLON typename SEMI
                ;
formal_params   ::= LPAREN fp_section formal_params1 RPAREN
                | LPAREN RPAREN
                ;
formal_params1  ::= formal_params1 SEMI fp_section  /* New Symbol*/
                |   SEMI fp_section
                ;
fp_section      ::= ID fp_section1 COLON typename
                ;
fp_section1     ::= fp_section1 COMMA ID    /* New Symbol*/
                |   COMMA ID
                ;
statement       ::=  lvalue ASGN expression SEMI
                |    ID actual_params SEMI
                |    READ LPAREN lvalue RPAREN SEMI
                |    READ LPAREN lvalue statement_lst RPAREN SEMI
                |    WRITE write_params SEMI
                |    IF expression THEN END SEMI
                |    IF expression THEN statement_lst
                      ELSIF expression THEN statement_lst
                      ELSE statement_lst END SEMI 
                |    WHILE expression DO statement_lst END SEMI
                |    WHILE expression DO END SEMI
                |    LOOP statement_lst END SEMI
                |    LOOP END SEMI
                |    FOR ID ASGN expression TO expression DO statement_lst END
                |    FOR ID ASGN expression TO expression BY expression 
                      DO statement_lst END SEMI
                |    EXIT SEMI
                |    RETURN expression:e SEMI         {: RESULT = new ReturnValueSt(e); :}
                |    RETURN SEMI                      {: RESULT = new ReturnSt(); :}
                ;
write_params    ::=  LPAREN write_expr RPAREN
                |    LPAREN write_expr write_params1 RPAREN
                ;
write_params1   ::=  write_params1 COMMA write_expr   /* New Symbol*/
                |    COMMA write_expr
                ;
write_expr      ::=  STRING_LITERAL
                |    expression
                ;
expression      ::=  number
                |    lvalue
                |    LPAREN expression RPAREN
                |    MINUS expression %prec UMINUS
                |    NOT expression
                |    expression PLUS expression
                |    expression MINUS expression
                |    expression TIMES expression
                |    expression SLASH expression
                |    expression DIV expression
                |    expression MOD expression
                |    expression OR expression
                |    expression AND expression
                |    expression GT expression
                |    expression LT expression
                |    expression EQ expression
                |    expression GEQ expression
                |    expression LEQ expression
                |    expression NEQ expression
                |    ID actual_params
                |    ID record_inits
                |    ID array_inits
                ;
lvalue          ::=  ID
                |    lvalue LSQBRA expression RSQBRA 
                |    lvalue DOT ID
                ;
actual_params   ::=  LPAREN expression actual_params1 RPAREN
                |    LPAREN RPAREN
                ;
actual_params1  ::=  actual_params1 COMMA expression    /* New Symbol*/
                |    COMMA expression
                ;
record_inits    ::=  LCUBRA ID ASGN expression record_inits1 RCUBRA
                ;
record_inits1   ::=  record_inits1 SEMI ID ASGN expression    /* New Symbol*/
                |    SEMI ID ASGN expression
                ;
array_inits     ::=  LCUBRA RCUBRA
                |    LCUBRA array_init array_inits1 RCUBRA
                ;
array_inits1    ::=  array_inits1 COMMA array_init   /* New Symbol*/
                |    COMMA array_init
                ;
array_init      ::= expression
                | expression OF expression
                ;
number          ::= INTEGER_LITERAL | REAL_LITERAL
                ;