/********************************************************************************
*
* File: pcat.cup
* The PCAT parser
*
********************************************************************************/

package edu.uta.pcat;

import scala.collection.immutable.*;
import scala.Tuple2;
import java_cup.runtime.*;


parser code {:

    static int[] tokens = {
      sym.error, sym.ID, sym.STRING_LITERAL, sym.INTEGER_LITERAL, sym.REAL_LITERAL,
      sym.AND, sym.ARRAY, sym.BEGIN, sym.BY, sym.DIV, sym.DO, sym.ELSE, sym.ELSIF, sym.END,
      sym.EXIT, sym.FOR, sym.IF, sym.IS, sym.LOOP, sym.MOD, sym.NOT, sym.OF, sym.OR,
      sym.PROCEDURE, sym.PROGRAM, sym.READ, sym.RECORD, sym.RETURN, sym.THEN, sym.TO,
      sym.TYPE, sym.VAR, sym.WHILE, sym.WRITE, sym.ASGN, sym.PLUS, sym.MINUS, sym.TIMES, sym.SLASH,
      sym.LT, sym.LEQ, sym.GT, sym.GEQ, sym.EQ, sym.NEQ, sym.COLON, sym.SEMI, sym.COMMA, sym.DOT,
      sym.LPAREN, sym.RPAREN, sym.LSQBRA, sym.RSQBRA, sym.LCUBRA, sym.RCUBRA
    };

    static String[] token_names = {
      "error", "ID", "STRING_LITERAL", "INTEGER_LITERAL", "REAL_LITERAL",
      "AND", "ARRAY", "BEGIN", "BY", "DIV", "DO", "ELSE", "ELSIF", "END",
      "EXIT", "FOR", "IF", "IS", "LOOP", "MOD", "NOT", "OF", "OR",
      "PROCEDURE", "PROGRAM", "READ", "RECORD", "RETURN", "THEN", "TO",
      "TYPE", "VAR", "WHILE", "WRITE", "ASGN :=", "PLUS +", "MINUS -", "TIMES *", "SLASH /",
      "LT <", "LEQ <=", "GT >", "GEQ >=", "EQ =", "NEQ <>", "COLON :", "SEMI ;", "COMMA ,", "DOT .",
      "LPAREN (", "RPAREN )", "LSQBRA [", "RSQBRA ]", "LCUBRA "+'{', "RCUBRA "+'}'
    };

    public static String print ( Symbol s ) {
        for ( int i = 0; i < tokens.length; i++ ) {
            if (tokens[i] == s.sym) {
                String res = token_names[i] + " ";
                if (s.value == null)
                    return res;
                else if (s.value instanceof Integer)
                    return res + ((Integer) s.value).intValue();
                else if (s.value instanceof Float)
                    return res + ((Float) s.value).floatValue();
                else if (s.value instanceof String)
                    return res + "\"" + (String) s.value + "\"";
            }
        };
        return "?";
    }

    public void syntax_error ( Symbol token ) {
        System.err.println("*** Syntax Error: " + print(token) + " (line: " + token.left
                           + ", column: " + token.right + ")");
        System.exit(1);
    }

    /** nil is the empty list */
    final static List nil = Nil$.MODULE$;

    /** Append list2 at the end of list1 (ie, return a new list containing
        the elements from list1 followed by the elements from list2) */
    static<T> List<T> append ( List<T> list1, List<T> list2 ) {
        return list1.$colon$colon$colon(list2);
    }

    /** append the element elem at the end of the list
       (ie, return a new list containing the list followed by the elem) */
    static<T> List<T> append ( List<T> list, T elem ) {
        return nil.$colon$colon(elem).$colon$colon$colon(list);
    }

    /** Insert the element elem at the beginning of the list
        (ie, return a new list containing the elem followed by the list) */
    static<T> List<T> add ( T elem, List<T> list ) {
        return list.$colon$colon(elem);
    }

:};

/* Terminals (tokens returned by the scanner). */
terminal String  ID, STRING_LITERAL;
terminal Integer INTEGER_LITERAL;
terminal Float   REAL_LITERAL;
terminal         AND, ARRAY, BEGIN, BY, DIV, DO, ELSE, ELSIF, END, EXIT, FOR, IF, IS, LOOP, MOD,
                 NOT, OF, OR, PROCEDURE, PROGRAM, READ, RECORD, RETURN, THEN, TO, TYPE, VAR, WHILE,
                 WRITE, ASGN, PLUS, MINUS, TIMES, SLASH, LT, LEQ, GT, GEQ, EQ, NEQ, COLON, SEMI,
                 COMMA, DOT, LPAREN, RPAREN, LSQBRA, RSQBRA, LCUBRA, RCUBRA, UMINUS;

non terminal             program;
non terminal Body        body;
non terminal Expr        expression;
non terminal Stmt        statement;
non terminal List<Stmt>  statement_lst;
non terminal             number;
non terminal             array_init;
non terminal             array_inits;
non terminal             array_inits1;
non terminal             record_inits;
non terminal             record_inits1;
non terminal             actual_params;
non terminal             actual_params1;
non terminal             lvalue;
non terminal             write_expr;
non terminal             write_params;
non terminal             write_params1;

precedence nonassoc ELSE;
precedence nonassoc ELSIF;
precedence right  OR;
precedence right  AND;
precedence nonassoc NOT;
precedence left   EQ, LT, GT, LEQ, GEQ, NEQ;
precedence left   PLUS, MINUS;
precedence left   TIMES, SLASH, DIV, MOD;

start with program;

program         ::= PROGRAM IS body:b SEMI            {: PCAT.setAST(new ProcDecl("main","NoType",nil,b)); :}
                ;
body            ::= BEGIN statement_lst:sl END        {: RESULT = new Body(nil,sl); :}
                ;
statement_lst   ::= statement:s                       {: RESULT = add(s,nil); :}
                |   statement_lst:sl statement:s      {: RESULT = append(sl,s); :}
                ;
statement       ::=  RETURN expression:e SEMI         {: RESULT = new ReturnValueSt(e); :}
                |    RETURN SEMI                      {: RESULT = new ReturnSt(); :}
                ;
write_params    ::=  LPAREN write_expr RPAREN
                |    LPAREN write_expr write_params1 RPAREN
                ;
write_params1   ::=  write_params1 COMMA write_expr
                |    write_expr
                ;
write_expr      ::=  STRING_LITERAL
                |    expression
                ;
expression      ::=  number
                |    lvalue
                |    LPAREN expression RPAREN
                |    MINUS expression %prec UMINUS
                |    NOT expression
                |    expression PLUS expression
                |    expression MINUS expression
                |    expression TIMES expression
                |    expression SLASH expression
                |    expression DIV expression
                |    expression MOD expression
                |    expression OR expression
                |    expression AND expression
                |    expression GT expression
                |    expression LT expression
                |    expression EQ expression
                |    expression GEQ expression
                |    expression LEQ expression
                |    expression NEQ expression
                |    ID actual_params
                |    ID record_inits
                |    ID array_inits
                |    ID
                ;
lvalue          ::=  lvalue LSQBRA expression RSQBRA COMMA ID
                |    lvalue DOT ID
                ;
actual_params   ::=  LPAREN expression RPAREN
                |    LPAREN expression actual_params1 RPAREN
                |    LPAREN RPAREN
                ;
actual_params1  ::=  actual_params1 COMMA expression
                |    COMMA expression
                ;

record_inits    ::=  LCUBRA ID ASGN expression record_inits1 RCUBRA
                |    LCUBRA ID ASGN expression RCUBRA
                ;
record_inits1   ::=  record_inits1 COMMA SEMI ID ASGN expression
                |    SEMI ID ASGN expression
                ;
array_inits     ::=  LCUBRA RCUBRA
                |    LCUBRA array_init RCUBRA
                |    LCUBRA array_init COMMA array_inits1 RCUBRA
                ;
array_inits1    ::=  array_init
                |    array_inits1 COMMA array_init
                ;
array_init      ::= expression
                | expression OF expression
                ;
number          ::= INTEGER_LITERAL | REAL_LITERAL
                ;