/********************************************************************************
*
* File: pcat.cup
* The PCAT parser
*
********************************************************************************/

package edu.uta.pcat;

import scala.collection.immutable.*;
import scala.Tuple2;
import java_cup.runtime.*;


parser code {:

    static int[] tokens = {
      sym.error, sym.ID, sym.STRING_LITERAL, sym.INTEGER_LITERAL, sym.REAL_LITERAL,
      sym.AND, sym.ARRAY, sym.BEGIN, sym.BY, sym.DIV, sym.DO, sym.ELSE, sym.ELSIF, sym.END,
      sym.EXIT, sym.FOR, sym.IF, sym.IS, sym.LOOP, sym.MOD, sym.NOT, sym.OF, sym.OR,
      sym.PROCEDURE, sym.PROGRAM, sym.READ, sym.RECORD, sym.RETURN, sym.THEN, sym.TO,
      sym.TYPE, sym.VAR, sym.WHILE, sym.WRITE, sym.ASGN, sym.PLUS, sym.MINUS, sym.TIMES, sym.SLASH,
      sym.LT, sym.LEQ, sym.GT, sym.GEQ, sym.EQ, sym.NEQ, sym.COLON, sym.SEMI, sym.COMMA, sym.DOT,
      sym.LPAREN, sym.RPAREN, sym.LSQBRA, sym.RSQBRA, sym.LCUBRA, sym.RCUBRA
    };

    static String[] token_names = {
      "error", "ID", "STRING_LITERAL", "INTEGER_LITERAL", "REAL_LITERAL",
      "AND", "ARRAY", "BEGIN", "BY", "DIV", "DO", "ELSE", "ELSIF", "END",
      "EXIT", "FOR", "IF", "IS", "LOOP", "MOD", "NOT", "OF", "OR",
      "PROCEDURE", "PROGRAM", "READ", "RECORD", "RETURN", "THEN", "TO",
      "TYPE", "VAR", "WHILE", "WRITE", "ASGN :=", "PLUS +", "MINUS -", "TIMES *", "SLASH /",
      "LT <", "LEQ <=", "GT >", "GEQ >=", "EQ =", "NEQ <>", "COLON :", "SEMI ;", "COMMA ,", "DOT .",
      "LPAREN (", "RPAREN )", "LSQBRA [", "RSQBRA ]", "LCUBRA "+'{', "RCUBRA "+'}'
    };

    public static String print ( Symbol s ) {
        for ( int i = 0; i < tokens.length; i++ ) {
            if (tokens[i] == s.sym) {
                String res = token_names[i] + " ";
                if (s.value == null)
                    return res;
                else if (s.value instanceof Integer)
                    return res + ((Integer) s.value).intValue();
                else if (s.value instanceof Float)
                    return res + ((Float) s.value).floatValue();
                else if (s.value instanceof String)
                    return res + "\"" + (String) s.value + "\"";
            }
        };
        return "?";
    }

    public void syntax_error ( Symbol token ) {
        System.err.println("*** Syntax Error: " + print(token) + " (line: " + token.left
                           + ", column: " + token.right + ")");
        System.exit(1);
    }

    /** nil is the empty list */
    final static List nil = Nil$.MODULE$;

    /** Append list2 at the end of list1 (ie, return a new list containing
        the elements from list1 followed by the elements from list2) */
    static<T> List<T> append ( List<T> list1, List<T> list2 ) {
        return list1.$colon$colon$colon(list2);
    }

    /** append the element elem at the end of the list
       (ie, return a new list containing the list followed by the elem) */
    static<T> List<T> append ( List<T> list, T elem ) {
        return nil.$colon$colon(elem).$colon$colon$colon(list);
    }

    /** Insert the element elem at the beginning of the list
        (ie, return a new list containing the elem followed by the list) */
    static<T> List<T> add ( T elem, List<T> list ) {
        return list.$colon$colon(elem);
    }

:};

/* Terminals (tokens returned by the scanner). */
terminal String  ID, STRING_LITERAL;
terminal Integer INTEGER_LITERAL;
terminal Float   REAL_LITERAL;
terminal         AND, ARRAY, BEGIN, BY, DIV, DO, ELSE, ELSIF, END, EXIT, FOR, IF, IS, LOOP, MOD,
                 NOT, OF, OR, PROCEDURE, PROGRAM, READ, RECORD, RETURN, THEN, TO, TYPE, VAR, WHILE,
                 WRITE, ASGN, PLUS, MINUS, TIMES, SLASH, LT, LEQ, GT, GEQ, EQ, NEQ, COLON, SEMI,
                 COMMA, DOT, LPAREN, RPAREN, LSQBRA, RSQBRA, LCUBRA, RCUBRA, UMINUS;

non terminal             program;
non terminal Body        body;
non terminal Expr        expression;
non terminal Stmt        statement;
non terminal List<Stmt>  statement_lst;
non terminal             number;
non terminal             array_init;
non terminal             array_inits;
non terminal             array_initsRec;
non terminal             record_inits;
non terminal             record_initsRec;
non terminal             actual_params;
non terminal             actual_paramsRec;
non terminal             lvalue;
non terminal             write_expr;
non terminal             write_params;
non terminal             write_paramsRec;
non terminal             fp_section;
non terminal             fp_sectionRec;
non terminal             formal_params;
non terminal             formal_paramsRec;
non terminal             component;
non terminal             type;
non terminal             component_lst;
non terminal             procedure_decl;
non terminal             procedure_decls;
non terminal             procedure_declsRec;
non terminal             type_decl;
non terminal             type_decls;
non terminal             type_declsRec;
non terminal             var_decl;
non terminal             var_declRec;
non terminal             var_decls;
non terminal             var_declsRec;
non terminal             declaration;
non terminal             typename;
non terminal             declaration_lst;
non terminal             var_type_dec;
non terminal             elsif_lst;
non terminal            var_decl_type;
non terminal            procedure_decl_type;
non terminal            statement_else_type;
non terminal            statement_expression_type;
non terminal            for_decl_type;
non terminal            array_inits_type;
non terminal            array_init_type;

precedence nonassoc ELSE;
precedence nonassoc ELSIF;
precedence right  OR;
precedence right  AND;
precedence nonassoc NOT;
precedence left   EQ, LT, GT, LEQ, GEQ, NEQ;
precedence left   PLUS, MINUS;
precedence left   TIMES, SLASH, DIV, MOD;
precedence left   LPAREN, RPAREN;


start with program;

program         ::= PROGRAM IS body:b SEMI      
                ;
body            ::= BEGIN statement_lst END
                |   declaration_lst BEGIN statement_lst END
                ;
statement_lst   ::= statement                    /* New Symbol*/
                |   statement_lst:sl statement:s      
                |   statement_lst COMMA lvalue
                |   COMMA lvalue
                ;
declaration_lst ::= declaration
                |   declaration_lst declaration   /* New Symbol*/
                ;
declaration     ::= VAR var_decls
                | TYPE type_decls
                | PROCEDURE procedure_decls
                ;
var_decls       ::= var_decl var_declsRec  
                ;
var_declsRec   ::= var_declsRec var_decl   /* New Symbol*/
                |  var_decl
                ;
var_decl        ::= ID var_declRec var_decl_type ASGN expression SEMI
                ;
var_decl_type   ::= COLON typename
                ;
var_declRec       ::= var_declRec COMMA ID /* New Symbol*/
                |   COMMA ID
                ;
type_decls      ::= type_decl type_declsRec
                ;
type_declsRec     ::= AND type_decl
                |   type_declsRec AND type_decl  /* New Symbol*/
                ;
type_decl       ::= typename IS type SEMI
                ;
procedure_decls ::= procedure_decl procedure_declsRec
                ;
procedure_declsRec::= procedure_declsRec AND procedure_decl  /* New Symbol*/
                |   AND procedure_decl
                ;
procedure_decl  ::= ID formal_params procedure_decl_type IS body SEMI
                ;
procedure_decl_type ::= COLON typename
                ;
typename        ::= ID
                ;
type            ::= ARRAY OF typename
                |   RECORD component component_lst END
                ;
component_lst   ::= component
                |   component_lst component   /* New Symbol*/
                ;
component       ::= ID COLON typename SEMI
                ;
formal_params   ::= LPAREN fp_section formal_paramsRec RPAREN
                | LPAREN RPAREN
                ;
formal_paramsRec  ::= formal_paramsRec SEMI fp_section  /* New Symbol*/
                |   SEMI fp_section
                ;
fp_section      ::= ID fp_sectionRec COLON typename
                ;
fp_sectionRec     ::= fp_sectionRec COMMA ID    /* New Symbol*/
                |   COMMA ID
                ;
statement       ::=  lvalue ASGN expression SEMI
                |    ID actual_params SEMI
                |    READ LPAREN lvalue statement_lst RPAREN SEMI
                |    WRITE write_params SEMI
                |    IF expression THEN statement_lst
                      elsif_lst
                      statement_else_type END SEMI  
                |    WHILE expression DO statement_lst END SEMI
                |    WHILE expression DO END SEMI
                |    LOOP statement_lst END SEMI
                |    LOOP END SEMI
                |    FOR ID ASGN expression TO expression for_decl_type
                      DO statement_lst END
                |    EXIT SEMI
                |    RETURN statement_expression_type SEMI  
                |    RETURN SEMI                      
                ;
statement_else_type ::= ELSE statement_lst
                ;
statement_expression_type ::= expression
                ;
for_decl_type   ::= BY expression
                ;
elsif_lst       ::=  elsif_lst ELSIF expression THEN statement_lst
                |    ELSIF expression THEN statement_lst
                ;
write_params    ::=  LPAREN write_expr RPAREN
                |    LPAREN write_expr write_paramsRec RPAREN
                |    LPAREN RPAREN
                ;
write_paramsRec   ::=  write_paramsRec COMMA write_expr   /* New Symbol*/
                |    COMMA write_expr
                ;
write_expr      ::=  STRING_LITERAL
                |    expression
                ;
expression      ::=  number
                |    lvalue
                |    LPAREN expression RPAREN
                |    MINUS expression %prec UMINUS
                |    NOT expression
                |    expression PLUS expression
                |    expression MINUS expression
                |    expression TIMES expression
                |    expression SLASH expression
                |    expression DIV expression
                |    expression MOD expression
                |    expression OR expression
                |    expression AND expression
                |    expression GT expression
                |    expression LT expression
                |    expression EQ expression
                |    expression GEQ expression
                |    expression LEQ expression
                |    expression NEQ expression
                |    ID actual_params
                |    ID record_inits
                |    ID array_inits
                ;
lvalue          ::=  ID
                |    lvalue LSQBRA expression RSQBRA 
                |    lvalue DOT ID
                ;
actual_params   ::=  LPAREN expression actual_paramsRec RPAREN
                |    LPAREN RPAREN
                ;
actual_paramsRec::=  actual_paramsRec COMMA expression    /* New Symbol*/
                |    COMMA expression
                ;
record_inits    ::=  LCUBRA ID ASGN expression record_initsRec RCUBRA
                ;
record_initsRec ::=  record_initsRec SEMI ID ASGN expression    /* New Symbol*/
                |    SEMI ID ASGN expression
                ;
array_inits     ::=  LCUBRA array_inits_type RCUBRA
                ;
array_inits_type::= array_init array_initsRec
                ;
array_initsRec  ::=  array_initsRec COMMA array_init   /* New Symbol*/
                |    COMMA array_init
                ;
array_init      ::= array_init_type expression
                ;
array_init_type ::= expression OF
                ;
number          ::= INTEGER_LITERAL | REAL_LITERAL
                ;